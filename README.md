# eshop-inventory

数据库和缓存一致性解决方案


**问题1**：如果是先修改数据库，再删除缓存，如果删除缓存失败，那么会导致数据库中的数据是新数据，缓存中的是旧数据
，数据不一致。

**解决思路**：先删除缓存，再修改数据库，如果删除缓存成功了，修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中



#Cache Aside Pattern
* 读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应

* 更新的时候，先删除缓存，然后再更新数据库

#为什么是删除缓存，而不是更新缓存
1，因为很多时候缓存不是直接数据库直接取出来的值，很可能做了逻辑运算以后再存入数据库
如果这类的数据要更新，则需要将相关的数据都查出来再去计算更新，这样代价太高了。

2，如果你频繁修改一个缓存涉及的多个表，那么这个缓存会被频繁的更新，频繁的更新缓存，但是问题在于，这个缓存到底会不会被频繁访问到？

```
举个例子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次，100 次; 但是这个缓存在 1 分钟内就被读取了 1 次，有大量的冷数据

热冷数据的 28 黄金法则：20% 的数据，占用了 80% 的访问量

实际上，如果你只是删除缓存的话，那么 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低

每次数据过来，就只是删除缓存，然后修改数据库，如果这个缓存，在 1 分钟内只是被访问了 1 次，那么只有那 1 次缓存是要被重新计算的，用缓存才去算缓存

```

>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算
mybatis、hibernate 就是懒加载思想


**问题2**：一个比较复杂的数据不一致问题
1，数据发生了变更，先删除缓存，然后要去修改数据库，此时还没修改
2，一个并发请求过来，去读缓存，发现缓存空了，然后去查询数据库，查到了修改前的值，放到缓存
这时候出现数据库和缓存不一致。

***解决思路***： 导致这种情况出现的原因是读写并发请求造成的，可以尝试将读请求和更新请求进行串行化处理


